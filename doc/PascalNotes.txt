                          AS OF 1/18/04

TYPES
- Only types INT, BOOLEAN, CHAR, REAL, SCALAR, SUBRANGE, RECORD and SET
  implemented
  - No PACKED types (actually, types are always packed).
  - FILE OF and TEXTFILE types partially supported
    - Not supported in TYPE block
    - TEXTFILE is defined as FILE OF CHAR vs PACKED FILE OF CHAR
    - No function returning FILE OF; No FILE OF
      procedure/function arguments
    - Only PROGRAM arguments can be declared type FILE OF
    - Only one file identifier per FILE OF declaration in type
      block.
    - Older name TEXT also supported
  - SET is limit to 16/32 (# bits in int) adjacent elements
  - Expressions are not strongly typed across different SCALAR types
    (see exprEnum in expr.h)
  - In RECORD CASE, there is no verification that the type of the tag
    is consistent with a case selector; the is check if the case selector
    constants are of the same type as the tag type identifier.

- No range checks on array indices
- Pointers
  - Can't pass pointers as VAR parameters
  - No pointer functions ??
  - No pointers to pointers

STATEMENTS
- The following statements not implemented:
    - No PROCEDURE call with PROCEDUREs or FUNCTIONs as parameters
- The following statements are only partially implemented
    - WITH statements cannot be nested.
    - Cannot reference "up the chain" in WITH statements.  Eg.
      suppose RECORD "a" contains RECORD "b" which contains "c" and
      that RECORD "a" also contains "d" so that we could write
        a.b.c OR a.d
      Then the following should work but is not yet supported:
      WITH a DO
        BEGIN
          WITH b DO
            BEGIN
              c := ..
              d := .. <== SHOULD WORK!!!
    - GOTO only partially implemented -- no stack corrections
      for GOTOs between loops, blocks, etc.  Use is DANGEROUS.

STANDARD PROCEDURES and FUNCTIONS
- The following statement procedures/functions not implemented:
    - GET, PUT, PACK, UNPACK, NEW
    - TBD
- No fieldwidth colon operator on WRITE arguments

FILE PROCEDURES and FUNCTIONS
- No all standard
- Most only operate in INPUT and OUTPUT for now
- Many are just stubs; many are not implemented at all

FreePascal
    AssignFile - Assign a name to a file
    Append - Opens an existing file for appending data to end of file and editing it
    BlockRead - Read data from an untyped file into memory
    BlockWrite - Write data from memory to an untyped file
    CloseFile - Close opened file
    EOF - Check for end of file
    Erase - Erase file from disk
    FilePos - Get position in file
    FileSize - Get size of file
    Flush - Write file buffers to disk
    IOResult - Return result of last file IO operation
    Read - Read from a text file
    ReadLn - Read from a text file and go to the next line
    Reset - Opens a file for reading
    Rewrite - Create a file for writing
    Seek - Change position in file
    SeekEOF - Set file position to end of file
    SeekEOLn - Set file position to end of line
    Truncate - Truncate the file at position
    Write - Write variable to a file
    WriteLn - Write variable to a text file and go to a new line

tutorialspoint.com
    procedure Append(var t: Text);  - Opens a file in append mode
    procedure Assign(out f: file; const Name:);  - Assigns a name to a file
    procedure Assign(out f: file; p: PChar);  - Assigns a name to a file
    procedure Assign(out f: file; c: Char);  - Assigns a name to a file
    procedure Assign(out f: TypedFile; const Name:);  - Assigns a name to a file
    procedure Assign(out f: TypedFile; p: PChar);  - Assigns a name to a file
    procedure Assign(out f: TypedFile; c: Char);  - Assigns a name to a file
    procedure Assign(out t: Text; const s:);  - Assigns a name to a file
    procedure Assign(out t: Text; p: PChar);  - Assigns a name to a file
    procedure Assign(out t: Text; c: Char);  - Assigns a name to a file
    procedure BlockRead(var f: file; var Buf; count: Int64; var Result: Int64);   - Reads data from a file into memory
    procedure BlockRead(var f: file; var Buf; count: LongInt; var Result: LongInt);  - Reads data from a file into memory
    procedure BlockRead(var f: file; var Buf; count: Cardinal; var Result: Cardinal);  - Reads data from a file into memory
    procedure BlockRead(var f: file; var Buf; count: Word; var Result: Word);  - Reads data from a file into memory
    procedure BlockRead(var f: file; var Buf; count: Word; var Result: Integer);  - Reads data from a file into memory
    procedure BlockRead(var f: file; var Buf; count: Int64);  - Reads data from a file into memory
    procedure BlockWrite(var f: file; const Buf; Count: Int64; var Result: Int64);  - Writes data from memory to a file
    procedure BlockWrite(var f: file; const Buf; Count: LongInt; var Result: LongInt);  - Writes data from memory to a file
    procedure BlockWrite(var f: file; const Buf; Count: Cardinal; var Result: Cardinal);  - Writes data from memory to a file
    procedure BlockWrite(var f: file; const Buf; Count: Word; var Result: Word);  - Writes data from memory to a file
    procedure BlockWrite(var f: file; const Buf; Count: Word; var Result: Integer);  - Writes data from memory to a file
    procedure BlockWrite(var f: file; const Buf; Count: LongInt);  - Writes data from memory to a file
    procedure Close(var f: file);  - Closes a file
    procedure Close(var t: Text);  - Closes a file
    function EOF(var f: file):Boolean;  - Checks for end of file
    function EOF(var t: Text):Boolean;  - Checks for end of file
    function EOF: Boolean;  - Checks for end of file
    function EOLn(var t: Text):Boolean;  - Checks for end of line
    function EOLn: Boolean;  - Checks for end of line
    procedure Erase(var f: file);  - Deletes file from disk
    procedure Erase(var t: Text);  - Deletes file from disk
    function FilePos( var f: file):Int64;  - Position in file
    function FileSize(var f: file):Int64;  - Size of file
    procedure Flush(var t: Text);  - Writes file buffers to disk
    function IOResult: Word;  - Returns result of last file IO operation
    procedure Read(var F: Text; Args: Arguments);  - Reads from file into variable
    procedure Read(Args: Arguments);  - Reads from file into variable
    procedure ReadLn(var F: Text; Args: Arguments);  - Reads from file into variable and goto next line
    procedure ReadLn(Args: Arguments);  - Reads from file into variable and goto next line
    procedure Rename(var f: file; const s:);  - Renames file on disk
    procedure Rename(var f: file; p: PChar);  - Renames file on disk
    procedure Rename(var f: file; c: Char);  - Renames file on disk
    procedure Rename(var t: Text; const s);  - Rename file on disk
    procedure Rename(var t: Text; p: PChar);  - Renames file on disk
    procedure Rename( var t: Text; c: Char);  - Renames file on disk
    procedure Reset(var f: file; l: LongInt);  - Opens file for reading
    procedure Reset(var f: file);  - Opens file for reading
    procedure Reset(var f: TypedFile);  - Opens file for reading
    procedure Reset(var t: Text);  - Opens file for reading
    procedure Rewrite(var f: file; l: LongInt);  - Opens file for writing
    procedure Rewrite(var f: file);  - Opens file for writing
    procedure Rewrite(var f: TypedFile);  - Opens file for writing
    procedure Rewrite(var t: Text);  - Opens file for writing
    procedure Seek(var f: file; Pos: Int64);  - Sets file position
    function SeekEOF(var t: Text):Boolean;  - Sets file position to end of file
    function SeekEOF: Boolean;  - Sets file position to end of file
    function SeekEOLn(var t: Text):Boolean;  - Sets file position to end of line
    function SeekEOLn: Boolean;  - Sets file position to end of line
    procedure SetTextBuf(var f: Text; var Buf);  - Sets size of file buffer
    procedure SetTextBuf(var f: Text; var Buf; Size: SizeInt);  - Sets size of file buffer
    procedure Truncate(var F: file);  - Truncate the file at position
    procedure Write(Args: Arguments);  - Writes variable to file
    procedure Write(var F: Text; Args: Arguments);  - Write variable to file
    procedure Writeln(Args: Arguments);  - Writes variable to file and append newline
    procedure WriteLn(var F: Text; Args: Arguments);  - Writes variable to file and append newline

Extended Pascal Features
- Type STRING is partially implemented.
- PACKED ARRAY[..] OF CHAR is not a string.
- SIZEOF built-in is supported

NON-standard Pascal extensions/differences

TYPES
- Hexadecimal constants.
- INPUT and OUTPUT parameters in PROGRAM statement are
  predeclared and optional.
- Unsigned integer types (word and LongWord)
- Long integer type (LongInteger and LongWord, LongInt is an alias).

OPERATORS
- Binary shift operators -- << and >> like in C
- '#', "<>", and "><" are all equivalent

COMPILER PSEUDO-OPERATIONS
- INCLUDE

STATEMENTS
- CASE statement expects integer expression for the switch
  variable
- ELSE in CASE statement

EXPRESSIONS

- Assumes sizeof(pointer) == sizeof(integer)

TODO LIST

o BUGS
- Implement PUT and GET.
- In FUNC/PROC calls, if simpleExpression fails to find a parameter (eg.,
  proc (,,), no error is detected.
- Type FILE OF is totally busted -- fix it
- Need to get max string size into stack somehow.  Runtime routines like
  strcat and strcatc need to know how big the string storage space is.
- Need logic to release string stack used by actual parameters after
  function/procedure call.
- There are lots of cases where the string stack is not being managed
  correctly (e.g., usesSection()).
- Redirection of input and output is not supported (e.g. see setting of
  input and output in CONST section of pageutils.pas).
- Input procedures in writeln() take the file number as an optional first
  parameter. If the optional file parameter is not supplied then the file
  associated with the built-in variable INPUT is tested.  Similarly,
  outout procedures would default to the built-in OUTPUT.  This has been
  fixed for some functions (like eof and eoln) but not all cases have been
  verified.
- Unit files with data declarations, but no implementation generate an
  error.
- There is a string stack memory leak:  There is no explicit logic to free
  string stack allocated for constant strings.  It eventually gets freed
  when a procedure, function, or program exits, but can waste log of memory within.

o IMPROVEMENTS
- In PTKN, verify that string stack does not overflow when
  character added.
- Option to turn on listing
- Option to interleave assembly language with listing
- Option to select string stack size (or let it grow dynamically)
- Option to select symbol table size (or let it grow dynamically)
- List file should only be produced if option provided.
- Provide instrumentation to use the line number data in the
  object files.  In debugger, display source line.  Allow stepping
  from source line to source line.
- Optimizer needs to be incorporated into compiler.
- arrayIndex needs to conform with Pascal standard.
- Need to have 32-bit integers and address
- Translation to register model
- Native code translator
- Linker and support multiple source files
- Runtime package
- Full extended pascal string support
- Other things from extended pascal:  'list of'
- Need to optimize out JMP .+1
- For compatibility, let  'packed array [n..m] of char;' be equivalent to
  string.
- Need to review all uses of string stack for identifiers and strings
  that get discarded.  Probably should get a get infrastructure.
- Add 16-bit word type

o ISSUES
- What happens in TYPE block if type is sTYPE or sFILE_OF?  Need
  to re-think all typing.  Maybe replace sTYPE and sFILE_OF with
  sINT_TYPE, sINT_ARRAY_TYPE, ..., sFILE_OF_INT,
  sFILE_OF_INT_ARRAY, etc.
- Is it really necessary or meaningful to allocate dstack for
  file buffers.
- Revisit procedure call logic in pexec.c & pdbg.c.  First stack parameter
  is calculated but never used.
- Decide what to do about type filename in tests/src/cgimail.pas
