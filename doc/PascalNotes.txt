                          AS OF 12/31/21

TYPES
- All basic types INT, BOOLEAN, CHAR, REAL, SCALAR, SUBRANGE, RECORD and SET
  implemented (along with some types from enhanced Pascal like STRING and
  short STRING types).
  - No PACKED types (actually, types are always packed).  This is a bug
    and needs to be revisited in the future.
  - FILE OF and TEXTFILE types are supported
    - TEXTFILE is not the same as a PACKED FILE OF CHAR.  The latter is
      is treated as a binary file but has some string-like behaviors for
      limited backward compatibility.
    - No function returning FILE OF; No FILE OF procedure/function arguments
    - Older name TEXT also supported as an alias for TEXTFILE
  - SET is limit to 16/32 (# bits in int) adjacent elements
  - Expressions are not strongly typed across different SCALAR types
    (see exprEnum in expr.h)
  - In RECORD CASE, there is no verification that the type of the tag
    is consistent with a case selector; the check is only if the case selector
    constants are of the same type as the tag type identifier.

- No range checks on array indices
- Pointers
  - Can't pass pointers as VAR parameters
  - No pointer functions ??
  - No pointers to pointers

STATEMENTS
- The following statements not implemented:
    - No PROCEDURE call with PROCEDUREs or FUNCTIONs as parameters
- The following statements are only partially implemented
    - WITH statements cannot be nested.
    - Cannot reference "up the chain" in WITH statements.  Eg.
      suppose RECORD "a" contains RECORD "b" which contains "c" and
      that RECORD "a" also contains "d" so that we could write
        a.b.c OR a.d
      Then the following should work but is not yet supported:
      WITH a DO
        BEGIN
          WITH b DO
            BEGIN
              c := ..
              d := .. <== SHOULD WORK!!!
    - GOTO only partially implemented -- no stack corrections
      for GOTOs between loops, blocks, etc.  Use is DANGEROUS.

STANDARD PROCEDURES and FUNCTIONS
- The following statement procedures/functions not implemented:
    - GET, PUT, PACK, UNPACK, NEW
    - TBD
- No fieldwidth colon operator on WRITE arguments or precision on REAL
  arguments.

FILE PROCEDURES and FUNCTIONS
- Not all standard

For comparison:
- FreePascal
    AssignFile - Assign a name to a file
    Append - Opens an existing file for appending data to end of file and editing it
    BlockRead - Read data from an untyped file into memory
    BlockWrite - Write data from memory to an untyped file
    CloseFile - Close opened file
    EOF - Check for end of file
    Erase - Erase file from disk
    FilePos - Get position in file
    FileSize - Get size of file
    Flush - Write file buffers to disk
    IOResult - Return result of last file IO operation
    Read - Read from a text file
    ReadLn - Read from a text file and go to the next line
    Reset - Opens a file for reading
    Rewrite - Create a file for writing
    Seek - Change position in file
    SeekEOF - Set file position to end of file
    SeekEOLn - Set file position to end of line
    Truncate - Truncate the file at position
    Write - Write variable to a file
    WriteLn - Write variable to a text file and go to a new line

- tutorialspoint.com
    procedure Append(var t: Text);  - Opens a file in append mode
    procedure Assign(out f: file; const Name:);  - Assigns a name to a file
    procedure Assign(out f: file; p: PChar);  - Assigns a name to a file
    procedure Assign(out f: file; c: Char);  - Assigns a name to a file
    procedure Assign(out f: TypedFile; const Name:);  - Assigns a name to a file
    procedure Assign(out f: TypedFile; p: PChar);  - Assigns a name to a file
    procedure Assign(out f: TypedFile; c: Char);  - Assigns a name to a file
    procedure Assign(out t: Text; const s:);  - Assigns a name to a file
    procedure Assign(out t: Text; p: PChar);  - Assigns a name to a file
    procedure Assign(out t: Text; c: Char);  - Assigns a name to a file
    procedure BlockRead(var f: file; var Buf; count: Int64; var Result: Int64);   - Reads data from a file into memory
    procedure BlockRead(var f: file; var Buf; count: LongInt; var Result: LongInt);  - Reads data from a file into memory
    procedure BlockRead(var f: file; var Buf; count: Cardinal; var Result: Cardinal);  - Reads data from a file into memory
    procedure BlockRead(var f: file; var Buf; count: Word; var Result: Word);  - Reads data from a file into memory
    procedure BlockRead(var f: file; var Buf; count: Word; var Result: Integer);  - Reads data from a file into memory
    procedure BlockRead(var f: file; var Buf; count: Int64);  - Reads data from a file into memory
    procedure BlockWrite(var f: file; const Buf; Count: Int64; var Result: Int64);  - Writes data from memory to a file
    procedure BlockWrite(var f: file; const Buf; Count: LongInt; var Result: LongInt);  - Writes data from memory to a file
    procedure BlockWrite(var f: file; const Buf; Count: Cardinal; var Result: Cardinal);  - Writes data from memory to a file
    procedure BlockWrite(var f: file; const Buf; Count: Word; var Result: Word);  - Writes data from memory to a file
    procedure BlockWrite(var f: file; const Buf; Count: Word; var Result: Integer);  - Writes data from memory to a file
    procedure BlockWrite(var f: file; const Buf; Count: LongInt);  - Writes data from memory to a file
    procedure Close(var f: file);  - Closes a file
    procedure Close(var t: Text);  - Closes a file
    function EOF(var f: file):Boolean;  - Checks for end of file
    function EOF(var t: Text):Boolean;  - Checks for end of file
    function EOF: Boolean;  - Checks for end of file
    function EOLn(var t: Text):Boolean;  - Checks for end of line
    function EOLn: Boolean;  - Checks for end of line
    procedure Erase(var f: file);  - Deletes file from disk
    procedure Erase(var t: Text);  - Deletes file from disk
    function FilePos( var f: file):Int64;  - Position in file
    function FileSize(var f: file):Int64;  - Size of file
    procedure Flush(var t: Text);  - Writes file buffers to disk
    function IOResult: Word;  - Returns result of last file IO operation
    procedure Read(var F: Text; Args: Arguments);  - Reads from file into variable
    procedure Read(Args: Arguments);  - Reads from file into variable
    procedure ReadLn(var F: Text; Args: Arguments);  - Reads from file into variable and goto next line
    procedure ReadLn(Args: Arguments);  - Reads from file into variable and goto next line
    procedure Rename(var f: file; const s:);  - Renames file on disk
    procedure Rename(var f: file; p: PChar);  - Renames file on disk
    procedure Rename(var f: file; c: Char);  - Renames file on disk
    procedure Rename(var t: Text; const s);  - Rename file on disk
    procedure Rename(var t: Text; p: PChar);  - Renames file on disk
    procedure Rename( var t: Text; c: Char);  - Renames file on disk
    procedure Reset(var f: file; l: LongInt);  - Opens file for reading
    procedure Reset(var f: file);  - Opens file for reading
    procedure Reset(var f: TypedFile);  - Opens file for reading
    procedure Reset(var t: Text);  - Opens file for reading
    procedure Rewrite(var f: file; l: LongInt);  - Opens file for writing
    procedure Rewrite(var f: file);  - Opens file for writing
    procedure Rewrite(var f: TypedFile);  - Opens file for writing
    procedure Rewrite(var t: Text);  - Opens file for writing
    procedure Seek(var f: file; Pos: Int64);  - Sets file position
    function SeekEOF(var t: Text):Boolean;  - Sets file position to end of file
    function SeekEOF: Boolean;  - Sets file position to end of file
    function SeekEOLn(var t: Text):Boolean;  - Sets file position to end of line
    function SeekEOLn: Boolean;  - Sets file position to end of line
    procedure SetTextBuf(var f: Text; var Buf);  - Sets size of file buffer
    procedure SetTextBuf(var f: Text; var Buf; Size: SizeInt);  - Sets size of file buffer
    procedure Truncate(var F: file);  - Truncate the file at position
    procedure Write(Args: Arguments);  - Writes variable to file
    procedure Write(var F: Text; Args: Arguments);  - Write variable to file
    procedure Writeln(Args: Arguments);  - Writes variable to file and append newline
    procedure WriteLn(var F: Text; Args: Arguments);  - Writes variable to file and append newline

Extended Pascal Features
- Type STRING and short strings are implemented.
- PACKED ARRAY[..] OF CHAR is not a string.
- INPUT and OUTPUT are text files.  Files of type TEXTFILE (TEXT) are text
  files.  All others of type FILE OF <type> are binary files.
- PACKED ARRAY[] OF CHAR has some legacy behavior that allow them some limited
  behavior like STRINGS
- SIZEOF and LENGTH built-in is supported

NON-standard Pascal extensions/differences

TYPES
- Hexadecimal constants.
- INPUT and OUTPUT parameters in PROGRAM statement are predeclared and optional.

OPERATORS
- Binary shift operators -- << and >> like in C
- '#', "<>", and "><" are all equivalent

COMPILER PSEUDO-OPERATIONS
- INCLUDE

STATEMENTS
- CASE statement expects integer expression for the switch
  variable
- ELSE in CASE statement

EXPRESSIONS

- Assumes sizeof(pointer) == sizeof(integer)

TODO LIST

o BUGS
- Implement PUT and GET.
- In FUNC/PROC calls, if simpleExpression fails to find a parameter (eg.,
  proc (,,), no error is detected.
- There are lots of cases where the string stack is not being managed
  correctly (e.g., usesSection()).

o IMPROVEMENTS
- In tokenizer, verify that string stack does not overflow when
  character added.
- Option to turn on listing
- Option to interleave assembly language with listing.  Source line numbers
  are already provided in the listing.
- Option to select symbol table size (or let it grow dynamically)
- List file should only be produced if option provided.
- Provide instrumentation to use the line number data in the
  object files.  In debugger, display source line.  Allow stepping
  from source line to source line.
- Need to have 32-bit integers and addresses.  Type LongInteger and LongWord.
- Unsigned integer types (16-bit word and 32-bit LongWord)
- Long integer type (LongInteger and LongWord, LongInt is an alias).
- Translation to register model
- Native code translator
- Linker and support multiple source files
- Other things from extended pascal:  'list of'
- Need to optimize out JMP .+1

o ISSUES
- Revisit procedure call logic in pexec.c & pdbg.c.  First stack parameter
  is calculated but never used.
- There is an issue with using file types as the first argument of most
  standard file I/O procedures and functions.  This is a one-pass compiler
  and before we consume the input, we must be certain that that first
  argument this is going to resolve into a file type.

  There is a particular problem if the first argument is a READ (or an
  ARRAY of RECORDS).  A RECORD could contain a file field that is selected
  further on.  All we know at the point of encountering the RECORD is that
  it is a RECORD; we cannot know the type of the RECORD field that is
  selected until we parse a little more.  So the logic will make bad
  decisions with RECORDS (and worse, with ARRAYs of RECORDs).

  An option disables all support for files in RECORDs and at least
  makes the behavior consistent by disallowing RECORDs containing files.
  Perhaps, in the future, we will add some kind of parse ahead logic to
  handle this case.
